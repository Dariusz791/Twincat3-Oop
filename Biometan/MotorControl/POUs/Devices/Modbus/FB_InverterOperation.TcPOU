<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_InverterOperation" Id="{69d5e8b6-d242-4c8d-a42f-563324e4dbde}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_InverterOperation

VAR
	
	MB           		: ModbusRtuMaster_KL6x22B;
	
	_stInverter			: ST_Inverter;
	_MBdata      		: ARRAY[0..40] OF WORD;	(* The size of this array can be adapted to the modbus slaves register area *)
 	_busy		 		: BOOL;	
	_timeoutvalue		: TIME:=T#3S;		            (* Timeout while waiting for an answer of the modbus slave *)
	
	_step		 		: INT;						(* Step of the control inverter program*)
	_iItfCount			: INT :=1;
	
	
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[


CASE _step OF
0:	(*Initialize*)
		MB.ReadRegs(Execute:= FALSE); (* initialize *)
		
		//set index of inverter FB  
		_iItfCount := 1;		
		_step:= 10;
		

	
10:	(*Read status of Inverter*) (*Sprawdzić status po wystąpieniu bledu przerwania komuikacji*)

		// Read the device settings
		_stInverter := Itf.aItfDriveInverter[_iItfCount].DeviceData;
		
		MB.ReadRegs(
			UnitID:=_stInverter.bDeviceId,
			Quantity:= 1,
			MBAddr:=3201,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);

	
//	eSLF1      := 568,	// błąd komunikacja Modbus przerwana i nieaktywna
//	enSL	   := 592,	// Stan po udanym resecie błędu komunikacji komedną eResetInv = 128
//	eRdy       := 561,	// Stan po ustawieniu gotowości Inverta komendą eReady = 14
//	eZeroSpeed := 567,  // Stan po ustawieniu komendy eFwd = 15 lub eRev = 2063 gdy jest zerowa prędkośc zadana speed = 0 
//	eFwdOper   := 1591, // Stan gdy napęd pracuje w kierunku przodu po komendzie eFwd = 15 i osiągnał zadaną prędkość
//	eRevOper   := 34359	// Stan gdy napęd pracuje w kierunku odwrotnym po komendzie eRev = 2063 i osiągnał zadaną prędkość 	

	
		IF NOT _busy THEN

			MB.ReadRegs(Execute:=FALSE);
			_stInverter.errorMdb := MB.ErrorId;		
		
			IF NOT MB.Error THEN
				_stInverter.wStatus := StatusWord(_MBdata[0]);
			END_IF
			
			IF _stInverter.wStatus = eSLF1 OR _stInverter.wStatus = 536  THEN
				_MBdata[0]:=0;
				_step :=20;
				_stInverter.eControl := eResetInv;
			ELSE
				_MBdata[0]:=0;
				_step :=20;			
			END_IF
		
		END_IF
		
	
		
20: 	(*Write Control Register*)

		CASE _stInverter.eControl OF
			eFwd:
			   _MBdata[0] := eFwd;
			eRev:
				_MBdata[0] := eRev;
			eResetInv:
				_MBdata[0] := eResetInv;		 
		ELSE
			_MBdata[0] := eReady;
		
		END_CASE
	
		
		MB.WriteSingleRegister(
			UnitID:=_stInverter.bDeviceId,
			Quantity:=1,
			MBAddr:=8501,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);

		IF NOT _busy THEN
			MB.ReadRegs(Execute:=FALSE);
			_step :=30;
		END_IF

30: 	(*Write the set frequency*)
		
		_MBdata[0] := _stInverter.rSpeed;
	
		MB.WriteSingleRegister(
					UnitID:=_stInverter.bDeviceId,
					Quantity:=1,
					MBAddr:=8502,
					cbLength:= 2,
					pMemoryAddr:= ADR(_MBdata[0]),
					Execute:= TRUE,
					Timeout:= _timeoutvalue,
					Busy => _busy	);
	
		IF NOT _busy THEN
			MB.WriteRegs(Execute:=FALSE);
			_step :=40;
		END_IF
		

40:	(*Read actual error of Inverter*)
	
		MB.ReadRegs(
			UnitID:=_stInverter.bDeviceId,
			Quantity:= 1,
			MBAddr:=7200,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);
			
		IF NOT _busy THEN
			MB.ReadRegs(Execute:=FALSE);
			_stInverter.errorMdb := MB.ErrorId;			
			IF NOT MB.Error THEN
				_stInverter.errorInv := _MBdata[0];
			END_IF
	
			_MBdata[0]:=0;
			_step :=50;	
			
			Itf.aItfDriveInverter[_iItfCount].DeviceData := _stInverter;	
		END_IF
		
50: (* Go to the next device*)
	
	IF _iItfCount < 1 THEN
		_iItfCount := _iItfCount +1;
		_step := 10;
	ELSE
		_step := 0;
		
	END_IF


	
END_CASE	
]]></ST>
    </Implementation>
    <Method Name="StatusWord" Id="{e6933e2b-4142-422c-ba7d-516e32170dda}">
      <Declaration><![CDATA[METHOD StatusWord : E_InverterStatusWord
VAR_INPUT
	refMBdata : REFERENCE TO ARRAY[0..40] OF WORD;  //wskaźnik do tablicy ze słowem Controlnym 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE refMBdata[0] OF
	
	568:
		StatusWord := eSLF1; // błąd komunikacja Modbus przerwana i nieaktywna
	592: 
		StatusWord := enSL; // Stan po udanym resecie błędu komunikacji komedną eResetInv = 128
	561: 
		StatusWord := eRdy; // Stan po ustawieniu gotowości Inverta komendą eReady = 14
	567:
		StatusWord := eZeroSpeed; // Stan po ustawieniu komendy eFwd = 15 lub eRev = 2063 gdy jest zerowa prędkośc zadana speed = 0 
	1591:
		StatusWord := eFwdOper; // Stan gdy napęd pracuje w kierunku przodu po komendzie eFwd = 15 i osiągnał zadaną prędkość
	34359:
		StatusWord := eRevOper; // Stan gdy napęd pracuje w kierunku odwrotnym po komendzie eRev = 2063 i osiągnał zadaną prędkość 
		
END_CASE



	
	
	]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>