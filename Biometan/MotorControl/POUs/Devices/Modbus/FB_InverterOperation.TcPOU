<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_InverterOperation" Id="{69d5e8b6-d242-4c8d-a42f-563324e4dbde}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_InverterOperation

VAR
	
	MB           		: ModbusRtuMaster_KL6x22B;
	
	_stInverter			: ST_Inverter;
	_MBdata      		: ARRAY[0..40] OF WORD;	(* The size of this array can be adapted to the modbus slaves register area *)
 	_busy		 		: BOOL;	
	_timeoutvalue		: TIME:=T#3S;		            (* Timeout while waiting for an answer of the modbus slave *)
	
	_step		 		: INT;						(* Step of the control inverter program*)
	_iItfCount			: INT :=1;
	
	
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[


CASE _step OF
0:	(*Initialize*)
		MB.ReadRegs(Execute:= FALSE); (* initialize *)
		
		//set index of inverter FB  
		_iItfCount := 1;		
		_step:= 10;
		

	
10:	(*Read status of Inverter*) (*Sprawdzić status po wystąpieniu bledu przerwania komuikacji*)

		// Read the device settings
		_stInverter := Itf.aItfDriveInverter[_iItfCount].DeviceData;
		
		MB.ReadRegs(
			UnitID:=_stInverter.bDeviceId,
			Quantity:= 1,
			MBAddr:=3201,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);

		
		IF NOT _busy THEN

			MB.ReadRegs(Execute:=FALSE);
			_stInverter.errorMdb := MB.ErrorId;		
		
			IF NOT MB.Error THEN
				_stInverter.wStatus := _MBdata[0];
			END_IF
			
			IF _stInverter.wStatus = 568 OR _stInverter.wStatus = 536  THEN
				_MBdata[0]:=0;
				_step :=20;
				_stInverter.eControl := eResetInv;
			ELSE
				_MBdata[0]:=0;
				_step :=20;			
			END_IF
		
		END_IF
		
	
		
20: 	(*Write Control Register*)

		CASE _stInverter.eControl OF
			eFwd:
			   _MBdata[0] := 15;
			eRev:
				_MBdata[0] := 2063;
			eResetInv:
				_MBdata[0] := 128;		 
		ELSE
			_MBdata[0] := 14;
		
		END_CASE
	
		
		MB.WriteSingleRegister(
			UnitID:=_stInverter.bDeviceId,
			Quantity:=1,
			MBAddr:=8501,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);

		IF NOT _busy THEN
			MB.ReadRegs(Execute:=FALSE);
			_step :=30;
		END_IF

30: 	(*Write the set frequency*)
		
		_MBdata[0] := _stInverter.rSpeed;
	
		MB.WriteSingleRegister(
					UnitID:=_stInverter.bDeviceId,
					Quantity:=1,
					MBAddr:=8502,
					cbLength:= 2,
					pMemoryAddr:= ADR(_MBdata[0]),
					Execute:= TRUE,
					Timeout:= _timeoutvalue,
					Busy => _busy	);
	
		IF NOT _busy THEN
			MB.WriteRegs(Execute:=FALSE);
			_step :=40;
		END_IF
		

40:	(*Read actual error of Inverter*)
	
		MB.ReadRegs(
			UnitID:=_stInverter.bDeviceId,
			Quantity:= 1,
			MBAddr:=7200,
			cbLength:= 2,
			pMemoryAddr:= ADR(_MBdata[0]),
			Execute:= TRUE,
			Timeout:= _timeoutvalue,
			Busy => _busy	);
			
		IF NOT _busy THEN
			MB.ReadRegs(Execute:=FALSE);
			_stInverter.errorMdb := MB.ErrorId;			
			IF NOT MB.Error THEN
				_stInverter.errorInv := _MBdata[0];
			END_IF
	
			_MBdata[0]:=0;
			_step :=50;	
			
			Itf.aItfDriveInverter[_iItfCount].DeviceData := _stInverter;	
		END_IF
		
50: (* Go to the next device*)
	
	IF _iItfCount < 1 THEN
		_iItfCount := _iItfCount +1;
		_step := 10;
	ELSE
		_step := 0;
		
	END_IF


	
END_CASE	
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>